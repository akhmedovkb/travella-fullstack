// backend/telegram/handlers/serviceActualHandler.js

const db = require("../../db");
const { tgSend } = require("../../utils/telegram");
const { buildSvcActualKeyboard } = require("../keyboards/serviceActual");

function parseSvcActualCallbackData(data) {
  const s = String(data || "");

  // –≤–∞—Ä–∏–∞–Ω—Ç—ã:
  // 1) svc_actual:123:yes
  // 2) svc_actual:yes:123
  const m1 = s.match(/^svc_actual:(\d+):(yes|no)$/i);
  if (m1) return { serviceId: Number(m1[1]), answer: m1[2].toLowerCase() };

  const m2 = s.match(/^svc_actual:(yes|no):(\d+)$/i);
  if (m2) return { serviceId: Number(m2[2]), answer: m2[1].toLowerCase() };

  return null;
}

async function loadServiceWithProvider(serviceId) {
  const q = await db.query(
    `
    SELECT
      s.id,
      s.title,
      s.status,
      s.category,
      s.details,
      s.provider_id,

      p.id AS provider_id,
      p.name AS provider_name,
      p.telegram_refused_chat_id,
      p.telegram_chat_id,
      p.telegram_web_chat_id
    FROM services s
    JOIN providers p ON p.id = s.provider_id
    WHERE s.id = $1
    LIMIT 1
    `,
    [serviceId]
  );
  return q.rows[0] || null;
}

function safeJson(v) {
  if (!v) return {};
  if (typeof v === "object") return v;
  if (typeof v === "string") {
    try {
      const parsed = JSON.parse(v);
      return parsed && typeof parsed === "object" ? parsed : {};
    } catch {
      return {};
    }
  }
  return {};
}

function pickTokenForCallback(fromChatId, providerRow) {
  // –µ—Å–ª–∏ callback –ø—Ä–∏—à—ë–ª –∏–∑ refused-—á–∞—Ç–∞ ‚Äî –æ—Ç–≤–µ—á–∞–µ–º/—à–ª—ë–º –∫–ª–∏–µ–Ω—Ç—Å–∫–∏–º –±–æ—Ç–æ–º
  const clientToken = process.env.TELEGRAM_CLIENT_BOT_TOKEN || "";
  const refusedChat = providerRow?.telegram_refused_chat_id;

  if (clientToken && refusedChat && String(fromChatId) === String(refusedChat)) {
    return clientToken;
  }
  // –∏–Ω–∞—á–µ (–Ω–∞ –±—É–¥—É—â–µ–µ) ‚Äî —Å—Ç–∞—Ä—ã–π –±–æ—Ç (tokenOverride –ø—É—Å—Ç–æ–π = —Å—Ç–∞—Ä—ã–π —Ç–æ–∫–µ–Ω –≤ tgSend)
  return "";
}

async function handleServiceActualCallback(ctx) {
  const data = ctx?.callbackQuery?.data || ctx?.update?.callback_query?.data || "";
  const parsed = parseSvcActualCallbackData(data);
  if (!parsed) return false;

  const { serviceId, answer } = parsed;

  const cb = ctx?.callbackQuery || ctx?.update?.callback_query || null;
  const cbId = cb?.id;
  const fromChatId = cb?.message?.chat?.id;

  if (!serviceId || !fromChatId) {
    // –µ—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º –ø–æ–Ω—è—Ç—å –∫—Ç–æ –Ω–∞–∂–∞–ª ‚Äî –ø—Ä–æ—Å—Ç–æ –≥–∞—Å–∏–º
    try {
      if (typeof ctx?.answerCbQuery === "function") {
        await ctx.answerCbQuery("–û—à–∏–±–∫–∞: –Ω–µ—Ç chatId", { show_alert: true });
      }
    } catch {}
    return true;
  }

  const svc = await loadServiceWithProvider(serviceId);
  if (!svc) {
    try {
      if (typeof ctx?.answerCbQuery === "function") {
        await ctx.answerCbQuery("–£—Å–ª—É–≥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", { show_alert: true });
      }
    } catch {}
    return true;
  }

  const allowedChatIds = [
    svc.telegram_refused_chat_id,
    svc.telegram_chat_id,
    svc.telegram_web_chat_id,
  ]
    .filter(Boolean)
    .map(String);

  if (!allowedChatIds.includes(String(fromChatId))) {
    try {
      if (typeof ctx?.answerCbQuery === "function") {
        await ctx.answerCbQuery("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", { show_alert: true });
      }
    } catch {}
    return true;
  }

  const tokenOverride = pickTokenForCallback(fromChatId, svc);

  const details = safeJson(svc.details);

  // meta —á—Ç–æ–±—ã –ù–ï —Å–ø—Ä–∞—à–∏–≤–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–Ω–æ –≤ —ç—Ç–æ—Ç –∂–µ –¥–µ–Ω—å
  const metaKey = "tg_actual_reminders_meta";
  const meta = details[metaKey] && typeof details[metaKey] === "object" ? details[metaKey] : {};
  meta.lastConfirmedAt = new Date().toISOString();
  meta.lastAnswer = answer;
  meta.lastServiceId = svc.id;

  details[metaKey] = meta;

  // –µ—Å–ª–∏ –æ—Ç–≤–µ—Ç "no" ‚Äî –¥–µ–ª–∞–µ–º –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω–æ
  if (answer === "no") {
    details.isActive = false;
  } else {
    details.isActive = true;
  }

  // —Å–æ—Ö—Ä–∞–Ω—è–µ–º details
  await db.query(
    `
    UPDATE services
    SET details = $2::jsonb
    WHERE id = $1
    `,
    [svc.id, JSON.stringify(details)]
  );

  // 1) –æ—Ç–≤–µ—Ç –Ω–∞ callback
  try {
    if (typeof ctx?.answerCbQuery === "function") {
      await ctx.answerCbQuery(answer === "yes" ? "‚úÖ –û—Ç–º–µ—á–µ–Ω–æ: –∞–∫—Ç—É–∞–ª—å–Ω–æ" : "üõë –û—Ç–º–µ—á–µ–Ω–æ: –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω–æ");
    }
  } catch (e) {
    // –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ
    console.error("[serviceActualHandler] answerCbQuery failed:", e?.message || e);
  }

  // 2) —É–±—Ä–∞—Ç—å –∫–Ω–æ–ø–∫–∏, —á—Ç–æ–±—ã –Ω–µ –∂–∞–ª–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ
  try {
    if (typeof ctx?.editMessageReplyMarkup === "function") {
      await ctx.editMessageReplyMarkup({ inline_keyboard: [] });
    }
  } catch (e) {
    console.error("[serviceActualHandler] editMessageReplyMarkup failed:", e?.message || e);
  }

  // 3) –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º (—á—Ç–æ–±—ã –±—ã–ª–æ —è–≤–Ω–æ –ø—Ä–æ –∫–∞–∫—É—é —É—Å–ª—É–≥—É)
  try {
    const text =
      (answer === "yes"
        ? `‚úÖ *–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ: –∞–∫—Ç—É–∞–ª—å–Ω–æ*\n\n`
        : `üõë *–û—Ç–º–µ—á–µ–Ω–æ: –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω–æ*\n\n`) +
      `üßæ *ID:* #${svc.id}\n` +
      `üß≥ *–£—Å–ª—É–≥–∞:* ${svc.title || "‚Äî"}`;

    await tgSend(
      fromChatId,
      text,
      { parse_mode: "Markdown", reply_markup: buildSvcActualKeyboard(svc.id, { isActual: answer === "yes" }) },
      tokenOverride,
      false
    );
  } catch (e) {
    console.error("[serviceActualHandler] confirm tgSend failed:", e?.message || e);
  }

  // ‚úÖ –æ–±—Ä–∞–±–æ—Ç–∞–ª–∏
  return true;
}

module.exports = { handleServiceActualCallback };
