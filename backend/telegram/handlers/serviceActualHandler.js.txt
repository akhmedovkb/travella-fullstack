// backend/telegram/handlers/serviceActualHandler.js

const db = require("../../db");
const {
  tgSend,
  tgAnswerCallbackQuery,
  tgEditMessageReplyMarkup,
} = require("../../utils/telegram");

const {
  buildSvcActualKeyboard,
  buildSvcActualDoneKeyboard,
} = require("../keyboards/serviceActual");

const TZ = "Asia/Tashkent";

function getLocalDateStr(date, timeZone = TZ) {
  const fmt = new Intl.DateTimeFormat("en-CA", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  });
  return fmt.format(date); // YYYY-MM-DD
}

function safeJsonParseMaybe(v) {
  if (!v) return {};
  if (typeof v === "object") return v;
  if (typeof v === "string") {
    try {
      const parsed = JSON.parse(v);
      return parsed && typeof parsed === "object" ? parsed : {};
    } catch {
      return {};
    }
  }
  return {};
}

async function loadServiceWithProvider(serviceId) {
  const id = Number(serviceId);
  if (!Number.isFinite(id)) return null;

  const q = await db.query(
    `
    SELECT
      s.id, s.title, s.details, s.category, s.status, s.provider_id,
      COALESCE(p.telegram_refused_chat_id, p.telegram_web_chat_id, p.telegram_chat_id) AS provider_chat_id
    FROM services s
    JOIN providers p ON p.id = s.provider_id
    WHERE s.id = $1
    LIMIT 1
    `,
    [id]
  );

  return q.rows[0] || null;
}

async function updateServiceMeta(serviceId, patchJsonb) {
  const id = Number(serviceId);
  if (!Number.isFinite(id)) return;

  await db.query(
    `
    UPDATE services
    SET details = COALESCE(details::jsonb, '{}'::jsonb) || $2::jsonb
    WHERE id = $1
    `,
    [id, JSON.stringify(patchJsonb || {})]
  );
}

// core: handle callback from CLIENT BOT
async function handleServiceActualCallback(ctxLike) {
  const CLIENT_BOT_TOKEN = process.env.TELEGRAM_CLIENT_BOT_TOKEN || "";
  if (!CLIENT_BOT_TOKEN) return false;

  const cb = ctxLike?.callbackQuery || ctxLike?.update?.callback_query || null;
  if (!cb?.data) return false;

  const data = String(cb.data || "");
  if (!data.startsWith("svc_actual:")) return false;

  const parts = data.split(":"); // svc_actual:{id}:{action}
  const serviceId = parts[1];
  const action = parts[2] || "ping";

  const chatId = cb?.message?.chat?.id;
  const messageId = cb?.message?.message_id;
  const cbId = cb?.id;

  // always answer callback (same bot)
  const answer = async (text, opts = {}) =>
    tgAnswerCallbackQuery(cbId, text, opts, CLIENT_BOT_TOKEN);

  const svc = await loadServiceWithProvider(serviceId);
  if (!svc) {
    await answer("Услуга не найдена", { show_alert: true });
    return true;
  }

  // Защита: нажимать может только владелец (тот же chat_id)
  if (svc.provider_chat_id && String(svc.provider_chat_id) !== String(chatId)) {
    await answer("Это не ваша услуга", { show_alert: true });
    return true;
  }

  const details = safeJsonParseMaybe(svc.details);
  const today = getLocalDateStr(new Date(), TZ);

  // мета для “уже отвечал сегодня”
  const metaKey = "tgActualMeta";
  const meta = details?.tg_actual_reminders_meta || details?.tgActualMeta || {};
  const nextMeta = {
    ...meta,
    lastConfirmedAt: new Date().toISOString(),
    lastConfirmedLocalDate: today,
    lastAction: action,
  };

  // ping — просто освежим клавиатуру
  if (action === "ping") {
    await answer("OK");
    if (chatId && messageId) {
      await tgEditMessageReplyMarkup(
        {
          chat_id: chatId,
          message_id: messageId,
          reply_markup: buildSvcActualKeyboard(svc.id, { serviceId: svc.id }),
        },
        CLIENT_BOT_TOKEN
      );
    }
    return true;
  }

  // YES: подтвердил актуальность
  if (action === "yes") {
    // фиксируем мету и isActive=true
    const patch = {
      [metaKey]: nextMeta,
      isActive: true,
    };
    await updateServiceMeta(svc.id, patch);

    await answer("Подтверждено ✅");

    // меняем кнопки на “подтверждено”
    if (chatId && messageId) {
      await tgEditMessageReplyMarkup(
        {
          chat_id: chatId,
          message_id: messageId,
          reply_markup: buildSvcActualDoneKeyboard(svc.id, "yes"),
        },
        CLIENT_BOT_TOKEN
      );
    }

    // (опционально) короткое сообщение, чтобы явно было “про какую услугу”
    const title = svc.title || "—";
    await tgSend(
      chatId,
      `✅ Подтверждено: *${title}* (Услуга #${svc.id})`,
      { parse_mode: "Markdown" },
      CLIENT_BOT_TOKEN
    );

    return true;
  }

  // NO: снять как неактуально
  if (action === "no") {
    const patch = {
      [metaKey]: nextMeta,
      isActive: false,
    };
    await updateServiceMeta(svc.id, patch);

    await answer("Снято ❌");

    if (chatId && messageId) {
      await tgEditMessageReplyMarkup(
        {
          chat_id: chatId,
          message_id: messageId,
          reply_markup: buildSvcActualDoneKeyboard(svc.id, "no"),
        },
        CLIENT_BOT_TOKEN
      );
    }

    const title = svc.title || "—";
    await tgSend(
      chatId,
      `❌ Снято как неактуально: *${title}* (Услуга #${svc.id})`,
      { parse_mode: "Markdown" },
      CLIENT_BOT_TOKEN
    );

    return true;
  }

  await answer("Неизвестная команда", { show_alert: true });
  return true;
}

module.exports = {
  handleServiceActualCallback,
};
